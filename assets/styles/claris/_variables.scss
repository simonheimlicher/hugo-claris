@use 'sass:math';
@use 'hugo-vars' as hugo;

$list-excerpt-width: 20rem;
$list-excerpt-width: math.div((hugo.$screenViewBreakpointWidthOneColumn - (3 * hugo.$screenViewInnerPaddingOneColumn) ), 2);

// $list-style-indent: 0.16667em;
$list-style-indent: 1em;

$heading-padding-top: 0.5rem;
$heading-margin-top: 1.5rem;

$main-z-index: 1;

@mixin generate_colors($colors) {
  // Add RGB / RGBA color definitions
  @each $color, $value in $colors {
    --#{$color}: #{$value};
    // --RGB_#{$color}: #{mapColorVarToRGB($colors, $value)};
  }
  // Only define RGB values for select colors
  @each $color in (text bg theme theme-bg choice-bg xhaze link link-visited link-hover link-focus link-active link-dark link-dark-visited link-dark-hover link-dark-focus link-dark-active highlight-bg-yellow) {
    $value: map-get($colors, $color);
    --RGB_#{$color}: #{mapColorVarToRGB($colors, $value)};
  }
}

@function direction($value) {
  @if index('right' 'left', $value) != null {
    @return 'x';
  }
  @if index('top' 'bottom', $value) != null {
    @return 'y';
  }
  @error "Expected 'top', 'right', 'bottom' or 'left' but got #{$value}";
}

@function is-number($value) {
  @return type-of($value) == 'number';
}

@function is-null($value) {
  @return type-of($value) == 'null';
}

@function is-absolute-length($value) {
  @return type-of($value) == 'number' and index('cm' 'mm' 'in' 'px' 'pt' 'pc', unit($value)) != null;
}

@mixin element-padding($where: 'outer', $top: null, $right: null, $bottom: null, $left: null) {
  @if is-null($right) and (not is-null($top)) {
    $right: $top
  }
  @if is-null($bottom) and (not is-null($top)) {
    $bottom: $top
  }
  @if is-null($left) and (not is-null($right)) {
    $left: $right;
  }

  $pVar: ('top': $top, 'right': $right, 'bottom': $bottom, 'left': $left);
  @each $key, $value in $pVar {
    $direction: direction($key);
    @if type-of($value) == 'number' {
      @if is-absolute-length(#{$value}) {
        // @debug "absolute-length: #{$value}";
        $pVar: map-merge($pVar, (
          #{$key}: calc( max(#{$value}, env(safe-area-inset-#{$key}, 0px) ) )
        ));
      }
      @else {
        $valueVar: $value;
        @if $value == 0 {
          $valueVar: env(safe-area-inset-#{$key}, 0px)
        }
        @else {
          $valueVar: calc( max(#{$value} * var(--#{$where}_padding), env(safe-area-inset-#{$key}, 0px) ) )
        }
        $pVar: map-merge($pVar, (#{$key}: $valueVar));
        }
    }
    @else {
      $pVar: map-merge($pVar, (#{$key}: null) );
    }
  }
  // @debug "pVar: #{$pVar}";

  @media screen {
    @each $key, $value in $pVar {
      padding-#{$key}: #{$value};
    }
  }
}

@mixin inner_padding($padding-factor: 1) {
  @include element-padding('inner', $padding-factor, $padding-factor);
}

@mixin inner_padding_4-1 {
  $padding-factor: 0.25;
  @include element-padding('inner', $padding-factor, $padding-factor);
}

@mixin inner_padding_4-2 {
  $padding-factor: 0.5;
  @include element-padding('inner', $padding-factor, $padding-factor);
}

@mixin inner_padding_4-3 {
  $padding-factor: 0.75;
  @include element-padding('inner', $padding-factor, $padding-factor);
}

@mixin inner_horizontal-padding($padding-factor: 1) {
  @include element-padding('inner', unset, $padding-factor);
}

@mixin body_horizontal-padding($padding-factor: 1) {
  @include element-padding('body', unset, $padding-factor);
}

@mixin body_full-bleed_horizontal-padding($padding-factor: 0) {
  @include element-padding('body', unset, $padding-factor);
}

@mixin body_full-bleed_left-padding($padding-factor: 1) {
  @include element-padding('body', unset, 0, unset, $padding-factor);
}

@mixin background_dark() {
  background: var(--bg-dark);
  color: var(--text-dark);
  h1, h2, h3, h4, h5, h6 {
    color: var(--text-dark);
  }
  a {
    color: var(--link-dark);
    @supports (any-hover:hover) {
      &:hover {
        color: var(--link-dark-hover);
      }
      &:active {
        color: var(--link-dark-active);
      }
    }
  }
  svg.icon {
    fill: var(--text-dark);
  }
  .icon {
    img {
      background: none;
    }
    svg {
      fill: var(--text-dark);
    }
  }
}

@mixin link-lvhfa_color($attrs, $color-id, $override: null) {
  $variant: map-get($attrs, variant);
  $highlight: map-get($attrs, highlight);

  $color: link#{if($variant != null and $variant != '', -#{$variant}, '')}#{if($color-id != null and $color-id != '', -#{$color-id}, '')};
  @each $key, $attr in $highlight {
    $name: map-get($attr, name);
    $opacity: map-get($attr, opacity);
    @if ($override != null) {
      $opacity: $override;
    }
    @if ($opacity != null) {
      #{$name}: rgba(var(--RGB_#{$color}), $opacity);
    }
  }
}

@mixin link-lvhfa($underline: false, $variant: null, $text: text, $link: '', $visited: visited, $hover: hover, $focus: focus, $active: active) {
  @media screen {
    a {
      $attrs: (
        variant: #{$variant},
        highlight: (
          primary: (
            name: color,
            opacity: 1.0
          ),
          secondary: (
            name: text-decoration-color,
            opacity: 0.5
          )
        )
      );

      @if ($underline) {
        $attrs: map-merge($attrs, (
          primary: (
            name: text-decoration-color,
            opacity: 0.5
          ),
          secondary: (
            name: color,
            opacity: null
          )
        ));
        &, &:link, &:hover, &:visited, &:focus, &:active {
          color: var(--#{$text});
          text-decoration-line: underline;
          text-underline-position: under;
          text-underline-offset: 0.05em;
        }
      }
      @else {
        &, &:link, &:visited, &:focus {
          text-decoration: none;
        }
        &:hover, &:active {
          text-decoration-line: underline;
          text-underline-position: under;
          text-underline-offset: 0.05em;
        }
      }
      &, &:link {
        @include link-lvhfa_color($attrs, $link);
      }
      &:visited {
        @include link-lvhfa_color($attrs, $visited);
      }
      @media (any-hover: hover) {
        &:hover {
          @include link-lvhfa_color($attrs, $hover, 1.0);
        }
      }
      &:focus {
        @include link-lvhfa_color($attrs, $focus);
        outline: 1px dashed var(--link#{if($variant != null and $variant != '', -#{$variant}, '')}#{if($focus != null and $focus != '', -#{$focus}, '')});
        // background: var(--bg#{if($variant != null and $variant != '', -#{$variant}, '')}-hover);
      }
      &:active {
        @include link-lvhfa_color($attrs, $active, 1.0);
      }
    }
  }
  sub a, sup a, a.no-link, a.button, a.footnote-backref {
    text-decoration: none;
    &, &:link, &:hover, &:visited, &:focus, &:active {
      text-decoration: none;
    }
  }
}

@mixin link-lvhfa-inherit() {
  @media screen {
    a {
      &, &:link, &:visited, &:hover, &:focus, &:active {
        color: inherit;
        text-decoration: none;
      }
    }
    sub a, sup a, a.no-link, a.button, a.footnote-backref {
      color: inherit;
    }
  }
}

@mixin color-scheme_transition {
  html[data-color-scheme-transition] & {
    transition: background var(--color-scheme-duration) var(--color-scheme-timing);
  }
}

@mixin content_base() {
  clear: both;
}

@mixin content_base_centered() {
  @include content_base;
  // NOTE: Must not use width: 100% as otherwise
  // the grid track is exceeded when column-gap is > 0px
  // width: 100%;
  margin-left: auto;
  margin-right: auto;
}

@mixin content() {
  // Do nothing
}

@mixin content_singlecolumn() {
  @include body_horizontal-padding;
  @include content_base_centered;
  max-width: var(--content_max-width);
  // max-width: calc(min(100%, var(--content_max-width)));
}

// Content that has multiple columns
@mixin content_multicolumn() {
  @include body_horizontal-padding;
  @include content_base_centered;
  max-width: var(--content_max-width); // For IE 11
  @supports (display: grid) {
    max-width: var(--content_multicolumn_max-width);
    // NOTE: Not sure what (min(100%, ...) is supposed to accomplish.
    // Probably not needed anymore
    // max-width: calc(min(100%, var(--content_multicolumn_max-width)));
  }
}

// Content that has multiple panels that span the entire width
@mixin content_full-bleed() {
  @include content_base;
  padding: 0;
  margin: 0;
}

@mixin container() {
  // Do nothing
}

@mixin container_base() {
  // Do nothing
}

@mixin container_base_centered() {
  @include container_base;
  // NOTE: Must not use width: 100% as otherwise
  // the grid track is exceeded when column-gap is > 0px
  // width: 100%;
  margin-left: auto;
  margin-right: auto;
}

@mixin container_singlecolumn() {
  // @include inner_padding;
  // NOTE: Avoid large gap betweeen .content-title and .lede
  @include body_horizontal-padding;
  max-width: var(--content_max-width);
}

// Container that has multiple columns
@mixin container_multicolumn() {
  @include inner_padding;
  max-width: var(--content_max-width); // For IE 11
  @supports (display: grid) {
    max-width: var(--content_multicolumn_max-width);
  }
}

// Container that has multiple panels that span the entire width
@mixin container_full-bleed() {
  @include container_base;
  padding: 0;
  margin: 0;
}

// Limit width of chrome, i.e. header and footer
@mixin chrome() {
  @include content_base_centered;
  max-width: var(--screenViewWidthChrome);
}

@mixin footer() {
  @include content_base_centered;
  @include list-style_none;
  max-width: var(--screenViewWidthChrome);
}

@mixin content_wide() {
  @include content_base;
  max-width: var(--content_wide_max-width);
}

@mixin content_chrome-width() {
  @include content_base;
  max-width: var(--screenViewWidthChrome);
}

@mixin content_ultrawide() {
  @include content_base;
  max-width: var(--screenViewWidthUltrawide);
}

@mixin aside() {
  @include content_base;
  @media screen and (min-width: hugo.$screenViewBreakpointWidthWide) {
    @include geometric-scale('font-size', var(--font-size-aside));
  }
  font-size: var(--font-size-normal);
  h1, h2 {
    font-size: var(--font-size-larger-2);
  }
  h3 {
    font-size: var(--font-size-larger-1);
  }
  h4, h5, h6 {
    font-size: var(--font-size-normal);
  }
  @include list-style_none;
}

@mixin aside-meta() {
  @include content_base;
  @include geometric-scale('font-size', var(--font-size-aside-meta));
  font-size: var(--font-size-normal);
}

// @mixin list-style_indented($margin-vertical: math.div(hugo.$screenViewInnerPaddingMobile, 2), $padding-vertical: math.div(hugo.$screenViewInnerPaddingMobile, 2), $indent: $list-style-indent) {
@mixin list-style_indented($margin-horizontal: 0, $padding-horizontal: $list-style-indent, $margin-between: 0, $padding-between: 0.5em) {
    ul, ol {
    // list-style: disc outside none;;
    margin-left: $margin-horizontal;
    padding-left: $padding-horizontal;
    & > li + li {
      margin-top: $margin-between;
      padding-top: $padding-between;
    }
  }
  ul > li {
    list-style: disc outside;
    margin-left: 0.8em;
    padding-left: 0.2em;
    // Ensure the link provide a touch target of more than 32px
    & > a {
      // NOTE: Avoid `display: inline-flex` as this leads to inadvertent line breaks
      // and lack of spacing around elments contained inside, such as <em> or <strong>
      // display: inline-flex;
      display: inline-block;
      padding: calc(max(0px, 2.125rem - $padding-between - 1em * var(--line-height)) / 2) 0;
    }
    & > ul li {
      list-style-type: none;
      margin-left: 0;
      padding-left: 0.5em;
      &::before {
        content: '–';
        float: left;
        margin-left: -1.75em;
      }
      & > ul li  {
        margin-left: -0.25em;
        padding-left: 0.75em;
        list-style-type: circle;
        &::before {
          content: none;
        }
      }
    }
  }
  ol li {
    list-style: decimal outside;
    margin-left: 1em;
    padding-left: 0.5em;
  }
  li ul, li ol {
    padding-left: 1.25em;
  }
}

@mixin list-style_none($padding-between: 0.5em) {
  @include list-style_indented(0, 0, 0, $padding-between);
  ul > li {
    list-style: none;
    margin-left: 0;
    padding-left: 0;
    // Ensure the link provides a touch target of more than 32px
    & > a {
      // NOTE: Avoid `display: inline-flex` as this leads to inadvertent line breaks
      // and lack of spacing around elments contained inside, such as <em> or <strong>
      // display: inline-flex;
      display: inline-block;
      padding: calc(max(0px, 2.125rem - $padding-between - 1em * var(--line-height)) / 2) 0;
    }
    & > ul li {
      list-style-type: none;
      margin-left: 0;
      padding-left: 0.5em;
      &::before {
        content: none;
      }
    }
  }
}

// Inline list with separators
// - Uses clip-path
// - Works only if the ul is a block-level element
// https://www.jankollars.com/posts/multi-line-horizontal-list-with-separators/
@mixin block-separator-list($list-item-separation: 2ch, $list-separator: '•') {
  $shift-left: math.div($list-item-separation, 3.0);
  $list-sep-width: $shift-left + 0.5ch;
  ul {
    display: flex;
    flex-wrap: wrap;
    list-style: none;
    padding-left: 0;
    @supports (-webkit-clip-path: inset(0)) or (clip-path: inset(0)) {
      margin-left: 0.5ch - $list-item-separation - (0.5 * $list-sep-width);
      clip-path: inset(0 0 0 $list-item-separation - 0.5ch);
      & > * {
        padding-left: $list-item-separation;
      }
    }
    & > li, & > li + li {
      list-style: none;
      display: inline-block;
      margin: 0;
      padding: 0;
      &::before {
        content: $list-separator;
        display: inline-block;
        margin: 0 ($shift-left - 0.5ch) 0 (0.5 * $list-sep-width);
        width: $list-sep-width;
        text-align: center;
      }
      @supports (-webkit-clip-path: inset(0)) or (clip-path: inset(0)) {
        margin: 0 0 0 (-1 * ($shift-left + $list-sep-width));
        padding: 0 0 0 ($shift-left + $list-sep-width);
      }
    }
  }
}

@mixin inline-separator-list($list-item-separation: 2ch, $list-separator: '•') {
  $shift-left: math.div($list-item-separation, 3.0);
  $list-sep-width: $shift-left + 0.5ch;
  ul {
    display: inline;
    list-style: none;
    margin-left: -$list-item-separation + 0.5ch;
    &, & > li {
      margin-left: 0;
      padding-left: 0;
      list-style: none;
    }
    // The `li + li` is to override potentially existing declarations for siblings
    & > li, & > li + li {
      list-style: none;
      display: inline-block;
      margin: 0;
      padding: 0;
    }
    & > li:not(:last-child) {
      &::after {
        content: $list-separator;
        display: inline-block;
        margin: 0 0 0 ($shift-left - 0.5ch);
        width: $list-sep-width;
        text-align: center;
      }
      margin: 0 (-1 * ($shift-left + $list-sep-width)) 0 0;
      padding: 0 ($shift-left + $list-sep-width) 0 0;
    }
  }
}

@mixin viewport($width: 1024px, $margin: 25px) {
  max-width: $width;
  margin: $margin auto;
  @content;
}

@mixin shadow($opacity: 0.17) {
  box-shadow: 0 0 3rem rgba(0,0,0,$opacity);
  &:hover {
    box-shadow: 0 0 5rem rgba(0,0,0, (1.5 * $opacity));
  }
}

@mixin drop-shadow($dist: 3rem, $opacity: 0.2, $hover-opacity: 0.4) {
  box-shadow: 0 0 $dist hsla(0, 0%, 0%, $opacity);
  &:hover {
    box-shadow: 0 0 $dist hsla(0, 0%, 0%, $hover-opacity);
  }
  @media screen {
    html[data-color-scheme="dark"] & {
      box-shadow: 0 0 $dist hsla(0, 0%, 100%, $opacity);
      &:hover {
        box-shadow: 0 0 $dist hsla(0, 0%, 100%, $hover-opacity);
      }
    }
  }
  @media screen and (prefers-color-scheme: dark) {
    html:not([data-color-scheme="light"]) & {
      box-shadow: 0 0 $dist hsla(0, 0%, 100%, $opacity);
      &:hover {
        box-shadow: 0 0 $dist hsla(0, 0%, 100%, $hover-opacity);
      }
    }
  }
}

@mixin drop-shadow-offset($x: 0, $y: 0, $dist: 3rem, $opacity: 0.2, $hover-opacity: 0.4) {
  box-shadow: $x $y $dist rgba(0, 0, 0, $opacity);
  &:hover {
    box-shadow: $x $y $dist rgba(0, 0, 0, $hover-opacity);
  }
}

@mixin background-gradient-choice-haze($direction, $alpha) {
  background: linear-gradient(#{$direction},
    rgba(var(--RGB_choice-bg), #{$alpha}) 0%,
    rgba(var(--RGB_choice-bg), #{$alpha}) 20%,
    rgba(var(--RGB_xhaze), #{$alpha}) 90%,
    rgba(var(--RGB_xhaze), #{$alpha}) 100%);
}

@mixin background-gradient-translucent($direction, $alpha: 0.9, $alpha-blur: 0.6) {
  @include background-gradient-choice-haze($direction, $alpha);
  @if $alpha-blur > 0 {
    @supports ((-webkit-backdrop-filter: none) or (backdrop-filter: none)) {
      @include background-gradient-choice-haze($direction, $alpha-blur);
      backdrop-filter: blur(50px);
      -webkit-backdrop-filter: blur(50px);
    }
  }
}

/*
 * Ensure headings with ids (e.g. /about#experience) are not hidden by sticky header
 */
// https://stackoverflow.com/q/4086107/617559
// Other ideas: https://css-tricks.com/hash-tag-links-padding/, e.g.
//   https://codepen.io/kirkgleffe/pen/DfvuE

@mixin nav-bar-offset($offset: hugo.$screenViewNavHeight) {
  $anchor-offset: 1rem;
  .main_claris {
    padding-top: $offset;
    margin-top: 0;
    * {
      &[id]:target {
        scroll-margin-top: #{$anchor-offset + $offset};
      }
    }
  }
}

@mixin nav-bar-anchor-offset {
  @include nav-bar-offset(hugo.$screenViewNavHeightNarrow);
  @media screen and (min-width: hugo.$screenViewBreakpointWidthNarrow) {
    @include nav-bar-offset(hugo.$screenViewNavHeight);
  }
}

$familyDefaultMap: (
  styles: (
    default: (
      font-weight: 400,
      line-height: 1.5
    ),
    strong: (
      font-weight: 600,
    )
  ),
  roles: (
    display: (
      styles: (
        default: (
          font-weight: 400,
          line-height: 1.2
        ),
        strong: (
          font-weight: 600,
        )
      )
    )
  )
);

// Utility mixin to apply style definitions by defining CSS custom properties
// If $key is in $keysToDefineAsProperty, define the CSS custom property
// Currently, this is used to ensure we can access the current `line-height`
// to remove the line-height from the first line usinc `calc`
@mixin generateFontStyleProperties($defaultStyleDef, $baseStyleDef, $styleName, $styleDef) {
  // @debug 'generateFontStyleProperties(#{$styleName}): defaultStyleDef: #{inspect($defaultStyleDef)} baseStyleDef: #{inspect($baseStyleDef)}';
  // To enable consistently using the same style rules, we make some definitions available
  // as CSS custom properties.
  // This is used for example to have the weight of `strong` style available in `--font-weight-strong`
  // The values of some attributes such as `line-height` are required
  // for calculations.
  // List them in the following list to have them defined as CSS properties
  $keysToDefineAsProperty: ("line-height", "font-weight");

  @each $key, $value in $styleDef {
    @if index($keysToDefineAsProperty, $key) {
      $baseValue: map-get($defaultStyleDef, $key);
      @if $styleName != default {
        $baseValue: map-get($baseStyleDef, $key);
      }
      @if $value == $baseValue {
        // @debug 'generateFontStyleProperties(#{$styleName}): value=#{$value} == #{$baseValue}';
      }
      @else {
        // @debug 'generateFontStyleProperties(#{$styleName}): value=#{$value} != #{$baseValue}';
        $propertyName: $key;
        @if ($styleName != default) {
          $propertyName: #{$key}-#{$styleName};
        }
        --#{$propertyName}: #{$value};
      }
    }
  }
}

// Utility mixin to apply style definitions by defining CSS rules if they differ from default
@mixin generateFontStyleRules($defaultStyleDef, $baseStyleDef, $styleName, $styleDef) {
  // @debug 'generateFontStyleRules(#{$styleName}): defaultStyleDef: #{inspect($defaultStyleDef)} baseStyleDef: #{inspect($baseStyleDef)}';
  $overrideStyles: $styleDef;
  @if ($styleName == default) {
    // Determine, which values differ from default - if any
    $overrideStyles: ();
    @each $key, $value in $styleDef {
      $baseValue: map-get($defaultStyleDef, $key);
      @if ($baseValue and $value == $baseValue) {
        // @debug 'generateFontStyleRules(#{$styleName}): value=#{$value} == #{$baseValue}';
      }
      @else {
        // @debug 'generateFontStyleRules(#{$styleName}): value=#{$value} != #{$baseValue}';
        $overrideStyles: map-merge($overrideStyles, ($key: $value) );
      }
    }
  }
  @else {
    // Determine, which values differ from default - if any
    $overrideStyles: ();
    @each $key, $value in $styleDef {
      $baseValue: map-get($baseStyleDef, $key);
      @if ($baseValue and $value == $baseValue) {
        // @debug 'generateFontStyleRules(#{$styleName}): value=#{$value} == #{$baseValue}';
      }
      @else {
        // @debug 'generateFontStyleRules(#{$styleName}): value=#{$value} != #{$baseValue}';
        $overrideStyles: map-merge($overrideStyles, ($key: $value) );
      }
    }
  }

  @each $key, $value in $overrideStyles {
    #{$key}: #{$value};
  }
}

// Mixin to apply styles from a styles map
@mixin applyFontStyles($fontStackVariant, $defaultStyleDef, $baseStyleDef, $styleName, $styleDef, $baseSelector: null, $nestedSelector: null) {

  @if ($baseSelector == null) {
    @if ($styleName == default) {
      html {
        font-family: #{inspect($fontStackVariant)};
        @include generateFontStyleProperties($defaultStyleDef, $baseStyleDef, $styleName, $styleDef);
        @include generateFontStyleRules($defaultStyleDef, $baseStyleDef, $styleName, $styleDef);
      }
    }
    @else {
      html {
        @include generateFontStyleProperties($defaultStyleDef, $baseStyleDef, $styleName, $styleDef);
      }
      #{$styleName} {
        @include generateFontStyleRules($defaultStyleDef, $baseStyleDef, $styleName, $styleDef);
      }
    }
  }
  @else {
    @if ($nestedSelector == null) {
      @if ($styleName == default) {
        #{$baseSelector} {
          font-family: #{inspect($fontStackVariant)};
          @include generateFontStyleProperties($defaultStyleDef, $baseStyleDef, $styleName, $styleDef);
          @include generateFontStyleRules($defaultStyleDef, $baseStyleDef, $styleName, $styleDef);
        }
      }
      @else {
        #{$baseSelector} {
          @include generateFontStyleProperties($defaultStyleDef, $baseStyleDef, $styleName, $styleDef);
          #{$styleName} {
            @include generateFontStyleRules($defaultStyleDef, $baseStyleDef, $styleName, $styleDef);
          }
        }
        #{$styleName}#{$baseSelector} {
          @include generateFontStyleRules($defaultStyleDef, $baseStyleDef, $styleName, $styleDef);
        }
      }
    }
    @else {
      #{$baseSelector} {
        #{$nestedSelector} {
          @if ($styleName == default) {
            font-family: #{inspect($fontStackVariant)};
            @include generateFontStyleProperties($defaultStyleDef, $baseStyleDef, $styleName, $styleDef);
            @include generateFontStyleRules($defaultStyleDef, $baseStyleDef, $styleName, $styleDef);
          }
          @else {
            @include generateFontStyleProperties($defaultStyleDef, $baseStyleDef, $styleName, $styleDef);
            #{$styleName} {
              @include generateFontStyleRules($defaultStyleDef, $baseStyleDef, $styleName, $styleDef);
            }
          }
        }
        @if ($styleName != default) {
          #{$styleName}#{$nestedSelector} {
            @include generateFontStyleRules($defaultStyleDef, $baseStyleDef, $styleName, $styleDef);
          }
        }
      }
    }
  }
}

// Utility mixin to generate CSS rules
@mixin defineFontUtilityRules($fontStackVariant, $defaultStyleDef, $baseStyleDef, $styleName, $styleDef, $baseClassNames, $nestedClassNames: null) {
  @if length($baseClassNames) > 0 {
    $baseSelector: '.' + joinArray($baseClassNames, '.');
    $nestedSelector: null;
    @if $nestedClassNames != null and length($nestedClassNames) > 0 {
      $nestedSelector: '.' + joinArray($nestedClassNames, '.');
      // @debug 'nestedSelector=#{$baseSelector} #{$nestedSelector}';
    }
    @include applyFontStyles($fontStackVariant, $defaultStyleDef, $baseStyleDef, $styleName, $styleDef, $baseSelector, $nestedSelector);
  }
  @else {
    // Define the rules for the outermost element, typically HTML
    @include applyFontStyles($fontStackVariant, $defaultStyleDef, $baseStyleDef, $styleName, $styleDef);
  }
}

// Mixin to handle className combinations and generate rules
@mixin generateFontUtilityClasses($fontStackVariant, $defaultStyleDef, $baseStyleDef, $styleName, $styleDef, $classNames) {
  $len: length($classNames);
  // Generate rule for combined class
  @include defineFontUtilityRules($fontStackVariant, $defaultStyleDef, $baseStyleDef, $styleName, $styleDef, $classNames);
  @if $len > 1 {
    // Generate rules for all permutations (nested classes)
    @for $i from 1 through $len - 1 {
      $baseClassNames: sliceArray($classNames, 1, $i);
      $nestedClassNames: sliceArray($classNames, $i + 1, $len);
      @include defineFontUtilityRules($fontStackVariant, $defaultStyleDef, $baseStyleDef, $styleName, $styleDef, $baseClassNames, $nestedClassNames);
    }
  }
}

// Main mixin to define font styles
@mixin defineFontStyles($fontStackVariant, $defaultStyleDef, $stylesRole, $stylesVariant, $specStyles, $classNames) {
  // $baseStyleDef: updateMap(map-get($stylesRole, default), map-get($stylesVariant, default) );
  $defaultStyle: ();
  @if length($classNames) > 0 {
    $defaultStyle: $defaultStyleDef;
  }
  // Go through all styles
  @each $styleName, $specStyle in $stylesRole {
    $baseStyleDef: updateMap(map-get($stylesRole, $styleName), map-get($stylesVariant, $styleName) );
    $styleDef: updateMap($baseStyleDef, $specStyle);

    @if length($classNames) == 0 {
      $baseStyleDef: ();
    }

    // @debug 'defineFontStyles: defaultStyleDef: #{inspect($defaultStyleDef)} baseStyleDef: #{inspect($baseStyleDef)} styleDef: #{inspect($styleDef)}';
    // Note: To avoid an invalid CSS value error when $classNames is empty,
    // we append an empty list to it
    // @debug 'defineFontStyles: call generateFontUtilityClasses(#{nth($fontStackVariant, 1)}, styleName=#{$styleName}, classNames=#{append($classNames, ())})';
    // Generate rules
    @include generateFontUtilityClasses($fontStackVariant, $defaultStyle, $baseStyleDef, $styleName, $styleDef, $classNames);
  }
}

// Main mixin to define font variants
@mixin defineFontVariants($fontNameRole, $fallbackStackRole, $defaultStyleDef, $stylesRole, $specVariants, $classNames) {
  // Go through all variants
  @each $variant, $specVariant in $specVariants {
    $specStyles: map-get($specVariant, styles);

    @if $variant != default {
      $classNames: append($classNames, variant- + $variant);
    }

    $fontNameVariant: defaultTo($fontNameRole, map-get($specVariant, 'name'));
    $fallbackStackVariant: defaultTo($fallbackStackRole, map-get($specVariant, 'fallback'));
    $fontStackVariant: join(($fontNameVariant), $fallbackStackVariant);

    $stylesVariant: map-get($specVariant, 'styles');
    // Note: To avoid an invalid CSS value error when $classNames is empty,
    // we append an empty list to it
    // @debug 'defineFontVariants: call defineFontStyles(#{$fontNameRole}, classNames=#{append($classNames, ())})';
    @include defineFontStyles($fontStackVariant, $defaultStyleDef, $stylesRole, $stylesVariant, $specStyles, $classNames);
  }
}

@mixin defineFontRoles($specFamily, $classNames: () ) {
  // Default fallback stack to be used if all else fails.
  // Ensure to define a list here. If there is only one fallback font, append a comma: ('Fallback Font', )
  $fallbackStackDefault: ('Arial', );

  $fontNameFamily: map-get($specFamily, name);
  $fallbackStackFamily: map-get($specFamily, fallback);
  $fallbackStackFamily: defaultTo($fallbackStackDefault, map-get($specFamily, fallback));
  // --fallbackStackFamily: #{$fallbackStackFamily};

  $defaultStyleDef: map-get(map-get($familyDefaultMap, styles), default);

  $specStyles: updateMap(map-get($familyDefaultMap, styles), map-get($specFamily, styles));

  $specRolesDefault: updateMap((default: (styles: $specStyles)), map-get($familyDefaultMap, roles));
  $specRoles: updateMap($specRolesDefault, map-get($specFamily, roles));

  $specVariantsDefault: updateMap((default: (
    name: $fontNameFamily,
    fallback: $fallbackStackFamily,
    styles: $specStyles
  )), map-get($familyDefaultMap, variants));

  $specVariants: updateMap($specVariantsDefault, map-get($specFamily, variants));
  // @include mapToCSSProperties($specStyles, specStyles);
  // @include mapToCSSProperties($specRoles, specRoles);
  // @include mapToCSSProperties($specVariants, specVariants);

  // Go through all roles (default, display etc.) that are defined
  // for this font family's specification
  @each $role, $specRole in $specRoles {
    $defRole: updateMap(map-get($specRoles, default), $specRole);
    $fontNameRole: defaultTo($fontNameFamily, map-get($specRole, name));
    $fallbackStackRole: defaultTo($fallbackStackFamily, map-get($specRole, fallback));

    $stylesRole: updateMap($specStyles, map-get($specRole, styles));
    @if $role != default {
      $classNames: append($classNames, role- + $role);
    }
    // Note: To avoid an invalid CSS value error when $classNames is empty,
    // we append an empty list to it
    // @debug 'defineFontRoles: call defineFontVariants(#{$fontNameRole}, classNames=#{append((), $classNames)})';
    @include defineFontVariants($fontNameRole, $fallbackStackRole, $defaultStyleDef, $stylesRole, $specVariants, $classNames);
  }
}

/**
This mixin takes the **font specification** provided for the font family with the
provided `fontFamilyID` and turns it into a **font definition**, i.e.,
a map that comprises all the keys provided in `familyDefaultMap` and overrides
those provided by the font specification and adding any additional
role, variant, and style definitions
*/
@mixin defineFont($definitionID: default, $fontFamilyID: default) {

  // Get the specification of this font family
  $specFamily: map-get($fontFamilyMap, $fontFamilyID);

  @if ($specFamily) {
    // The font family with ID == default is applied at the HTML level
    $classNames: ();
    @if ($fontFamilyID != default) {
      // All other families generate utility classes with the font family ID
      // Note: define a list by adding a comma before the closing parenthesis
      $classNames: (font-#{$definitionID}, );
    }
    // @debug 'defineFont: call defineFontRoles(#{$fontFamilyID}, classNames=#{append((), $classNames)})';
    @include defineFontRoles($specFamily, $classNames);
  }
  @else {
    @warn "@mixin defineFont: font ID '#{$fontFamilyID}' is undefined";
  }
}

// Generating fluid font scales for copy-paste: https://www.fluid-type-scale.com/calculate https://utopia.fyi/type/calculator/
// Using SASS: https://www.smashingmagazine.com/2022/10/fluid-typography-clamp-sass-functions/
@function fluid($min-size, $max-size, $min-breakpoint: hugo.$screenViewBreakpointWidthMobile, $max-breakpoint: hugo.$screenViewBreakpointWidthWide, $unit: vw) {
  $slope: math.div($max-size - $min-size, $max-breakpoint - $min-breakpoint);
  $slope-to-unit: roundDec($slope * 100, 2);
  $intercept-rem: roundDec($min-size - $slope * $min-breakpoint, 2);
  $min-size-rem: roundDec($min-size, 2);
  $max-size-rem: roundDec($max-size, 2);
  @return clamp(#{$min-size-rem}, #{$slope-to-unit}#{$unit} + #{$intercept-rem}, #{$max-size-rem});
}

@function geometric-scaled-prop($prop, $scale-factor, $shift: 0, $factor-normal: 1) {
  @return calc(#{roundDec($factor-normal * math.pow($scale-factor, $shift), hugo.$fluidScaleDigits)} * var(--#{$prop}-base));
}

@mixin geometric-scale($prop, $base-size, $scale-factor: hugo.$geometricScaleFactor, $base-shift: 0, $smallest: 9, $largest: 9) {

  $smaller-factor-idx-max: 5;
  $larger-factor-idx-max: 6;
  --#{$prop}-base: #{$base-size};
  --#{$prop}-normal: #{geometric-scaled-prop($prop, $scale-factor, $base-shift)};
  @for $i from 1 through $smaller-factor-idx-max {
    --#{$prop}-smaller-#{$i}: #{geometric-scaled-prop($prop, $scale-factor, $base-shift - min($smallest, $i))};
  }
  @for $i from 1 through $larger-factor-idx-max {
    --#{$prop}-larger-#{$i}: #{geometric-scaled-prop($prop, $scale-factor, $base-shift + min($largest, $i))};
  }
}

@mixin fluid-geometric-scale($prop, $min-size, $max-size, $min-breakpoint: hugo.$screenViewBreakpointWidthMobile, $max-breakpoint: hugo.$screenViewBreakpointWidthWide, $unit: vw,
    $scale-factor: hugo.$geometricScaleFactor, $base-shift: 0, $smallest: 9, $largest: 9) {

  $smaller-factor-idx-max: 3;
  $larger-factor-idx-max: 6;

  --#{$prop}-base: #{fluid($min-size, $max-size, $min-breakpoint, $max-breakpoint, $unit)};

  --#{$prop}-normal: #{geometric-scaled-prop($prop, $scale-factor, $base-shift)};
  @for $i from 1 through $smaller-factor-idx-max {
    --#{$prop}-smaller-#{$i}: #{geometric-scaled-prop($prop, $scale-factor, $base-shift - min($smallest, $i))};
  }
  @for $i from 1 through $larger-factor-idx-max {
    --#{$prop}-larger-#{$i}: #{geometric-scaled-prop($prop, $scale-factor, $base-shift + min($largest, $i))};
  }
}

@function fractional-scaled-prop($prop, $numerator: hugo.$fractionalScaleDenominator, $denominator: hugo.$fractionalScaleDenominator, $factor-normal: 1) {
  @if ($numerator == $denominator) {
    @return var(--#{$prop}-base);
  }
  @return calc(#{roundDec($factor-normal * math.div($numerator, $denominator), hugo.$fluidScaleDigits)} * var(--#{$prop}-base));
}

@mixin fluid-fractional-scale($prop, $min-size, $max-size, $min-breakpoint: hugo.$screenViewBreakpointWidthMobile, $max-breakpoint: hugo.$screenViewBreakpointWidthWide, $unit: vw,
    $denominator: hugo.$fractionalScaleDenominator, $base-shift: 0) {

  // Define, up to how many times the $min-size we should define
  // E.g., with `$min-size: 1 rem`, `$denominator: 4` and `$numerator-max: 4 * $denominator`,
  // the maximal value will be 4rem:
  // ($numerator-max)   / $denominator * $min-size = 4rem
  // (4 * $denominator) / $denominator * $min-size = 4rem
  // (4 * 4             / 4            * 1rem      = 4rem
  $numerator-max: 4 * $denominator;

  --#{$prop}-base: #{fluid($min-size, $max-size, $min-breakpoint, $max-breakpoint, $unit)};
  --#{$prop}: #{fractional-scaled-prop($prop, $base-shift + $denominator, $denominator)};
  @for $i from 0 through $numerator-max {
    --#{$prop}_#{$denominator}-#{$i}: #{fractional-scaled-prop($prop, $base-shift + $i, $denominator)};
  }
}

html {
  // --dim-image-filter: grayscale(30%);
  --dim-image-filter: brightness(75%);

  --to-be-eliminated-by-csspurge: black;

  @include fluid-geometric-scale('font-size_root', 1rem, 1.25rem, hugo.$screenViewBreakpointWidthMobile, hugo.$screenViewBreakpointWidthOneColumn);
  @include fluid-geometric-scale('font-size', 1rem, 1.25rem, hugo.$screenViewBreakpointWidthMobile, hugo.$screenViewBreakpointWidthOneColumn);
  @include fluid-geometric-scale('font-size_heading', 1.25rem, 2rem, hugo.$screenViewBreakpointWidthMobile, hugo.$screenViewBreakpointWidthWide);
  // @include fluid-fractional-scale('inner_margin', 0.75rem, 2.5rem, hugo.$screenViewBreakpointWidthMobile, hugo.$screenViewBreakpointWidthWide);
  @include fluid-fractional-scale('body_margin', 0.75rem, 2.5rem, hugo.$screenViewBreakpointWidthMobile, hugo.$screenViewBreakpointWidthWide);
  @include fluid-fractional-scale('inner_margin', 0.75rem, 1.5rem, hugo.$screenViewBreakpointWidthMobile, hugo.$screenViewBreakpointWidthOneColumn);
  // @include fluid-fractional-scale('inner_margin', 0.75rem, 2.5rem, hugo.$screenViewBreakpointWidthMobile, hugo.$screenViewBreakpointWidthWide, vw, 8);
  // @include fluid-fractional-scale('inner_padding', 0.75rem, 2.5rem, hugo.$screenViewBreakpointWidthMobile, hugo.$screenViewBreakpointWidthWide);
  @include fluid-fractional-scale('body_padding', 0.75rem, 2.5rem, hugo.$screenViewBreakpointWidthMobile, hugo.$screenViewBreakpointWidthWide);
  @include fluid-fractional-scale('inner_padding', 0.75rem, 1.5rem, hugo.$screenViewBreakpointWidthMobile, hugo.$screenViewBreakpointWidthOneColumn);

  --font-size: var(--font-size-normal);
  --font-size-aside: var(--font-size_root-normal);
  --font-size-aside-meta: var(--font-size_root-smaller-1);
  --font-size-footer: var(--font-size_root-smaller-1);

  --font-size-lede: var(--font-size_root-larger-1);

  --font-size-meta: var(--font-size_root-smaller-1);
  // --font-size-button: var(--font-size-smaller-1);
  --font-size-button: var(--font-size-normal);

  --font-size-title: var(--font-size_heading-larger-4);
  --font-size-supertitle: var(--font-size_heading-normal);
  --font-size-subtitle: var(--font-size_heading-normal);

  --font-size-nav: var(--font-size-normal);

  --font-weight-strong: 700;
  --font-weight-light: 400;
  --font-weight-heading: 700;
  --font-weight-supertitle: 700;
  --font-weight-subtitle: 400;
  --font-weight-code: 400;

  // --line-height: 1.5;
  --line-height-heading: 1.2;
  --line-height-label: 1.2;


  --icon-height: 1.2em;
  --icon-height-nav: 1.5rem;
  --icon-height-meta: 1em;

  // --ease: cubic-bezier(.19,1,.22,1);
  --ease: cubic-bezier(0.39, 0.575, 0.565, 1);
  --easing: cubic-bezier(0.19, 1, 0.22, 1);

  /*! purgecss start ignore */
  --color-scheme: 'light';

  // https://web.dev/prefers-color-scheme/#activating-dark-mode-in-the-operating-system
  --color-scheme-duration: 0.7s;
  --color-scheme-timing: ease;
  /*! purgecss end ignore */

  --screenViewWidthChrome: #{hugo.$screenViewWidthChrome};
  --screenViewWidthUltrawide: #{hugo.$screenViewWidthUltrawide};

  --content_multicolumn_max-width: #{hugo.$screenViewWidthChrome};
  --content_max-width: #{hugo.$screenViewColumnWidthMax};
  --content_wide_max-width: #{hugo.$screenViewColumnWidthWideMax};
  // @media screen and (min-width: #{hugo.$screenViewBreakpointWidthWide}) {
  //   --content_max-width: #{hugo.$screenViewColumnWidthWideMax};
  // }

  --screenViewNavHeight: #{hugo.$screenViewNavHeightNarrow};
  @media screen and (min-width: #{hugo.$screenViewBreakpointWidthNarrow}) {
    --screenViewNavHeight: #{hugo.$screenViewNavHeight};
  }

$screenViewBreakpoints: (
    'width': (
      'mobile': hugo.$screenViewBreakpointWidthMobile,
      'narrow': hugo.$screenViewBreakpointWidthNarrow,
      'onecolumn': hugo.$screenViewBreakpointWidthOneColumn,
      'twocolumn': hugo.$screenViewBreakpointWidthTwoColumn,
      'wide': hugo.$screenViewBreakpointWidthWide,
      'ultrawide': hugo.$screenViewBreakpointWidthUltrawide,
    ),
    'height': (
      'shallow': hugo.$screenViewBreakpointHeightShallow,
      'tall': hugo.$screenViewBreakpointHeightTall,
    ),
  );

  $screenViewMargin: (
    'outer': (
      'mobile': hugo.$screenViewBodyMarginMobile,
      'narrow': hugo.$screenViewBodyMarginNarrow,
      'onecolumn': hugo.$screenViewBodyMarginOneColumn,
    ),
    'inner': (
      'mobile': hugo.$screenViewInnerMarginMobile,
      'narrow': hugo.$screenViewInnerMarginNarrow,
      'onecolumn': hugo.$screenViewInnerMarginOneColumn,
    ),
  );

  $screenViewPadding: (
    'outer': (
      'mobile': hugo.$screenViewBodyPaddingMobile,
      'narrow': hugo.$screenViewBodyPaddingNarrow,
      'onecolumn': hugo.$screenViewBodyPaddingOneColumn,
    ),
    'inner': (
      'mobile': hugo.$screenViewInnerPaddingMobile,
      'narrow': hugo.$screenViewInnerPaddingNarrow,
      'onecolumn': hugo.$screenViewInnerPaddingOneColumn,
    ),
  );

  // @mixin screen-margin-padding($breakpoint) {
  //   @each $where in ('outer', 'inner') {
  //     $marginBase: map-get(map-get(hugo.$screenViewMargin, $where), $breakpoint);
  //     $paddingBase: map-get(map-get(hugo.$screenViewPadding, $where), $breakpoint);
  //     @if $paddingBase {
  //       @each $sizeDesc, $numQuarters in ('-1': 1, '-2': 2, '-3': 3, '': 4) {
  //         @each $direction in ('x', 'y') {
  //           --#{$where}_margin-#{$direction}#{$sizeDesc}: #{math.div( $marginBase * $numQuarters, 4)};
  //           --#{$where}_padding-#{$direction}#{$sizeDesc}: #{math.div($paddingBase * $numQuarters, 4)};
  //         }
  //       }
  //     }
  //   }
  // }

  // $breakpointsWidth: map-get(hugo.$screenViewBreakpoints, 'width');
  // @for $i from 1 through length($breakpointsWidth) {
  //   $breakpointKeys: map-keys($breakpointsWidth);
  //   $breakpoint: nth($breakpointKeys, $i);
  //   $breakpointWidth: map-get(map-get(hugo.$screenViewBreakpoints, 'width'), $breakpoint);
  //   @if $i == 1 {
  //     @include screen-margin-padding($breakpoint);
  //   }
  //   @else {
  //     @media screen and (min-width: $breakpointWidth) {
  //       @include screen-margin-padding($breakpoint);
  //     }
  //   }
  // }

  --navigation-header-height: 0;

  @include generate_colors($colors-lit);
  --choice-bg-menu: var(--haze);
  --choice-bg-menu-active: var(--xxxhaze);

  @mixin color-scheme-dark {
    --theme-text-dim: hsla(0,0%,100%,0.87);
    --color-scheme: 'dark';
    --text: var(--theme-text-dim);
    --accent: var(--bubble);
    // --choice-bg: var(--bg);
    --code-bg: var(--translucent);
    --header-text: var(--theme-text-dim);
    --table-bg: var(--code-bg);
    --table-haze: hsla(0, 0%, 100%, 0.1);
    --table-border: var(--code-bg);
    --footer-bg: var(--bg);
    svg.icon {
      fill: var(--theme-text);
    }
    .icon {
      img {
        background: none;
      }
      svg {
        fill: #fafafa;
      }
    }
    .nav_color-scheme {
      &_choice {
        &_light {
          opacity: 0.0;
        }
        &_dark {
          opacity: 1.0;
        }
      }
    }
    @media (any-hover: hover) {
      &:not([data-color-scheme-transition]) .nav_color-scheme_choice:hover {
        .nav_color-scheme_choice {
          &_light {
            opacity: 1.0;
            z-index: 1;
          }
          &_dark {
            opacity: 0.0;
            transition: none;
            z-index: auto;
          }
        }
      }
    }

    @include generate_colors( map-merge($colors-lit, $colors-dim) );
    img:not([src*=".svg"]) {
      filter: var(--dim-image-filter);
    }
  }

  @media screen {
    &[data-color-scheme="dark"] {
      @include color-scheme-dark;
    }
  }
  @media screen and (prefers-color-scheme: dark) {
    &:not([data-color-scheme="light"]) {
      @include color-scheme-dark;
    }
  }

  &:not(.kind-page) {
    --choice-bg: var(--theme-bg);
    --RGB_choice-bg: var(--RGB_theme-bg);
  }
}

$fontStyles: (default, sans, serif, mono);
@each $style in $fontStyles {
  @include defineFont($style, $style);
}

$fontDefinitions: (
  (default, $fontTypeDefault),
  (content, $fontTypeContent),
  (article, $fontTypeArticle),
  (code, $fontTypeCode),
  (heading, $fontTypeHeading),
  (meta, $fontTypeMeta)
);

@each $defID, $defSpec in $fontDefinitions {
  // It is possible to define a font definition with the value `inherit`, e.g.,
  // (heading, $fontTypeHeading)
  // with `$fontTypeHeading` set to `inherit`
  // NOTE: Determine, how to determine the value of `inherit`. For the time being,
  // we simply treat it as a no-op, which will lead to the corresponding font utility
  // classes not being generated
  @if ($defSpec != inherit) {
    @include defineFont($defID, $defSpec);
  }
}
// @include defineFont(default, default);
